\section{Intro}
Queues are an important type of structures, and we often see them used as the basic tools for different algorithms. In imperative languages, it is easy to implement queues with $O(1)$ worst-case guarantees for \texttt{pop} and \texttt{inject}, with common implementations being a Linked List or a Circular Buffer. When using a functional language, such as Haskell, we do not have access to side-effects, and as such, implementing a queue with the nice $O(1)$ guarantees becomes much harder, and we need to make certain trade-offs, such as relying on amortization or global rebuilding. In this project we look at several different queue implementations in the functional lazy functional language of Haskell, and try to show their different properties through experiments.